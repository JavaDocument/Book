# CHAP02. 객체지향 프로그래밍

## 키워드

협력, 클래스, 다형성, 상속, 추상화, 추상클래스, 인터페이스

<br>

## 요약

객체지향은 요구사항 분석부처 프로그램 구현까지 추상화 기법을 사용하는 강력한 개발 방식이다. 
캡슐화와 접근 제어자를 통해 외부 경계가 명확한 클래스를 구현할 수 있으며, 클래스 내 메서드 실행 및 객체 간 메시지 전달을 통해 객체 간 협력이 이루어진다. 
객체지향에서는 추상 클래스, 인터페이스, 상속을 이용하여 코드 재사용성을 높이고 다형성을 가능하게 한다.

<br>

## 정리

### *객체지향은 ‘클래스’가 아니라 ‘객체’가 먼저다*

1. 클래스를 명세하기 이전에, 어떤 객체들이 필요한지 고민하고 그 객체들이 어떤 상태와 행동을 가지는지 결정한다.
2. 객체의 윤곽이 잡히면, 공통된 특성과 상태를 가진 객체들을 타입으로 분류하고, 타입을 기반으로 클래스를 구현한다.

### *객체지향 패러다임의 강력함*

- 요구사항을 분석하는 초기 단계부터 프로그램을 구현하는 마지막 단계까지 객체라는 동일한 추상화 기법을 사용할 수 있게 하기 때문에 절차지향보다 강력하다.

### *도메인*

- 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야
- 객체지향 프로그래밍에서는 요구사항과 프로그램을 객체라는 동일한 관점에서 바라볼 수 있기 때문에, 도메인을 구성하는 개념들이 프로그램의 객체와 클래스로 연결될 수 있다.
- 클래스의 이름 및 관계는 대응되는 도메인들과 비슷해야한다.
- ex) 영화 예매 시스템 내 도메인 : 상영, 예매, 영화, 할인 정책…

### *올바른 클래스 설계는 경계의 명확성에서 시작된다*

- 올바른 클래스 설계를 위해 개발자는 접근제어자를 통해 객체의 어떤 부분을 외부에 공개하고 감출지를 적절히 결정해야한다. (무분별한 접근과 상태 변경을 막아야 한다.)
- 경계의 명확성이 잘 구현된다면?
    1. 객체의 자율성이 보장된다.
    2. 프로그래머에게 구현의 자유를 제공한다.

### *객체의 특성*

1. 객체는 상태와 행동을 함께 가지는 복합적 존재
2. 객체는 스스로 판단하고 행동하는 자율적인 존재

### *인터페이스와 구현의 분리 원칙을 따르자*

‘인터페이스와 구현의 분리’ 원칙을 따르자면, 객체의 상태는 숨기고 행동만 외부에 공개해야 한다.

프로그래밍 중에는 캡슐화와 접근 제어자 사용을 통해 이 원칙을 지킬 수 있다.

1. **public interface (퍼블릭 인터페이스)** :  외부에서 접근 가능한 부분
2. **implementation (구현)** : 외부에서 접근 불가능, 오직 내부에서만 접근 가능한 부분

### **프로그래머의 자유를 위한 ‘구현 은닉’**

- 프로그래머의 역할
    - **클래스 작성자** : 새로운 데이터 타입을 프로그램에 추가한다. 클라이언트 프로그래머에게 필요한 부분만 공개하고 나머지는 숨겨야 한다.
    - **클라이언트 프로그래머** : 클래스 작성자가 추가한 데이터 타입을 사용한다. 필요한 클래스들을 엮어서 애플리케이션을 구축한다.
- **구현 은닉** : 위 역할에 따르면, 클래스 작성자가 숨겨 놓은 부분에 대해 클라이언트 프로그래머는 접근할 수 없을 것이다.
  결과적으로 클래스 작성자는 클라이언트 프로그래머에 의한 내부 변경을 걱정하지 않고도 내부 구현을 자유롭게 변경할 수 있다. 클라이언트 프로그래머는 알아야 할 내부 구현 정보의 양이 줄어들어 더 쉽게 클래스를 사용할 수 있다.

### **객체 간의 협력과 상호작용**

- **협력** : 시스템의 어떤 기능을 구현하기 위해 객체들 사이에 이뤄지는 상호작용 (ex. 서로의 메서드를 호출하며 실행되는 경우)
- 객체 간의 상호작용
    - 다른 객체의 인터페이스에 공개된 행동을 수행하도록 요청하는 ‘메시지’를 전송하는 것이 유일한 방법
    - 수신된 메시지를 처리하기 위한 객체 자신만의 방법을 ‘메서드’라고 한다.

### *추상 클래스와 인터페이스*

- **추상 클래스** : 두 클래스 사이의 중복 코드를 제거하기 위해 공통된 기능을 선언한 추상 메서드가 한 개 이상 포함된 클래스
- **인터페이스** : 구현에 대한 고려 없이 다형적인 협력에 참여하는 클래스들이 공유 가능한 외부 인터페이스를 정의한 것
- 차이점
    1. 추상 클래스는 인터페이스와 달리, 구현부가 포함된 일반 메서드도 정의할 수 있다.
- 공통점
    1. new 로 인스턴스를 생성할 수 없다.
    2. 추상 클래스나 인터페이스는 자식 클래스가 반드시 상속/구현해야 하는데, 이는 부모 클래스에 기본적인 알고리즘의 흐름을 구현하고 중간에 필요한 처리를 자식 클래스에 위임하는 디자인 패턴인 TEMPLATE METHOD 패턴을 가진다고 할 수 있다.

### *상속*

- **상속** : 두 클래스 사이의 관계를 정의하는 방법. 상속 관계를 선언함으로써 한 클래스(자식)는 자동으로 다른 클래스(부모)가 제공하는 코드를 자신의 일부로 합칠 수 있다. 기존 클래스를 기반으로 새로운 클래스를 쉽고 빠르게 추가할 수 있게 한다.
- 코드 재사용[구현 상속]과 다형적인 협력[인터페이스 상속]을 가능하게 한다.
- 상속을 통해 자식 클래스는 부모 클래스가 수신할 수 있는 모든 메시지를 수신할 수 있기 때문에, 외부 객체는 자식 클래스를 부모 클래스와 동일한 타입으로 간주할 수 있다.
- 메시지를 수신하는 객체의 타입에 따라, 한 가지 요청에 대해 다양한 응답을 할 수 있기 때문에 상속을 통해 **다형성**을 구현할 수 있다.

### *오버라이딩과 오버로딩*

- 오버라이딩 : 부모 클래스에 정의된 같은 이름, 같은 파라미터 목록을 가진 메서드를 자식 클래스에서 재정의하는 경우
- 오버로딩 : 메서드의 이름은 같지만 파라미터의 개수, 타입을 다르게 여러개 정의하는 경우

### *의존성의 양면성*

- 코드의 의존성(클래스 사이의 의존성)과 실행 시점의 의존성(객체 사이의 의존성)은 서로 다를 수 있다.
- 둘이 다르면 다를수록, 객체를 생성하고 연결하는 부분을 찾을 필요성이 커지기 때문에 한 눈에 이해하기 어려운 코드가 된다. 하지만, 코드는 더 유연해지고 확장 가능해진다.
- 유연한 설계, 높은 재사용성 ↔ 쉬운 코드 이해, 디버깅

### *다형성을 구현하는 동적 바인딩*

- **동적 바인딩(지연 바인딩)** : 메시지와 메서드를 실행 시점에 바인딩하는 것
- 컴파일 시점의 의존성과 실행 시점의 의존성을 분리하고, 하나의 메시지를 선택적으로 서로 다른 메서드에 연결할 수 있게 한다.

### *추상화와 유연성*

- 추상 클래스를 통해 추상화를 구현할 수 있는데, 장점은 밑과 같다.
    1. 요구사항의 정책을 높은 수준에서 서술할 수 있다.
        1. 세부사항에 억눌리지 않고 상위 개념만으로도 도메인의 중요한 개념을 설명할 수 있다.
        2. 자식 클래스들은 추상화를 이용해 정의한 상위 협력 흐름을 그대로 따를 수 있게 된다.
    2. 유연한 설계를 가능하게 한다.
        1. 기존 구조를 수정하지 않고도 새로운 클래스를 추가하는 것만으로 기능을 쉽게 추가하고 확장할 수 있다.
        2. 설계가 구체적인 상황에 결합되는 것을 방지한다.

### *합성과 상속*

- **합성** : 인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법, 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용하는 방법
- 상속의 단점
    - **캡슐화 위반** : 부모 클래스의 내부 구조를 잘 알아야 사용할 수 있다. 부모 클래스의 구현이 자식 클래스에게 노출되기 때문에 캡슐화가 약화된다.
    - **결합도 상승** : 부모 클래스를 변경할 때 자식 클래스도 함께 변경될 확률을 높인다.
    - **유연하지 않은 설계** : 부모 클래스와 자식 클래스 사이의 관계를 컴파일 시점에 결정하기 때문에 실행 시점에 객체의 종류를 변경하는 것이 불가능하다.

단점에서 이어져서, 코드 재사용을 위해서는 상속보다는 **합성**이 더 좋은 방법이다.
다만 다형성을 위해 인터페이스를 재사용하는 경우에는 **상속**과 **합성**을 함께 조합해서 사용해야 한다.

<br>

## 궁금한 점