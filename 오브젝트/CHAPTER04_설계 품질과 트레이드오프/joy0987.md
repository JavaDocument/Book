# CHAP04. 설계 품질과 트레이드오프

## 키워드

책임, 데이터, 캡슐화, 응집도, 결합도, 데이터 중심 설계, 접근자, 수정자

<br>

## 요약

캡슐화를 통해 높은 응집도와 낮은 결합도를 이룰 수 있게 하자. 클래스는 하나의 책임만 가져야 한다는 단일 책임 원칙을 기억하고, 객체가 협력 안에서 가져야 하는 한 가지의 책임을 수행할 수 있게 하는 설계를 하자. 접근자가 private 라고 캡슐화가 이뤄지는 것은 아니다. 꼭 필요한 상황이 아니라면, 객체의 상태에 접근하고 변경하는 로직은 그 객체 내부에서 수행하게 하자.

<br>

## 정리

### 객체의 책임에 초점을 맞추자

객체지향 설계에서 결합도와 응집도를 적절히 유지하려면, 객체의 상태가 아니라 객체의 행동에 초점을 맞춰야 한다. 장점은 밑과 같다.

1. 객체와 객체 간의 상호작용으로 설계 중심을 이동시킨다.
2. 필요한 상태가 캡슐화된 객체를 구현할 수 있게 한다.
3. 코드 변경으로 인해 외부 객체가 받는 영향이 줄어 든다.

### 객체를 단순한 데이터의 집합으로 보지 말아라

- 객체의 상태(데이터의 집합) ∈ 구현
- 구현은 불안정하고 변하기 쉽다. 고로 상태를 객체 분할의 중심축으로 삼으면 구현에 관한 세부사항이 객체의 인터페이스에 스며들어 캡슐화가 무너진다. → 변경에 취약한 설계 초래

### 데이터 중심 설계

객체가 포함해야 하는 데이터를 먼저 결정하는 설계 방법

### 캡슐화, 응집도, 결합도

- 캡슐화
    - 변경 가능성이 높은 부분을 객체 내부로 숨기는 추상화 기법
    - 한 곳에서 일어난 변경이 전체 시스템에 영향을 끼치지 않도록 하기에 객체지향 설계에서 가장 중요하다.
- 응집도
    - 모듈에 포함된 내부 요소들이 연관돼 있는 정도
    - 객체지향 관점에서, 객체 또는 클래스에 얼마나 관련 높은 책임을 할당했는가
    - **하나의 목적**을 위해 긴밀하게 협력한다면 응집도가 높다고 할 수 있다.
- 결합도
    - 의존성의 정도, 한 모듈이 변경되기 위해서 다른 모듈의 변경을 요구하는 정도
    - 객체지향 관점에서, 객체 또는 클래스가 협력에 필요한 적절한 수준의 관계만을 유지하고 있는가
    - 꼭 필요한 지식만 알고 있다면 두 모듈은 낮은 결합도를 갖고 있다고 할 수 있다.

### 높은 응집도와 낮은 결합도를 추구하자

변경이 일어났을 때, 하나의 모듈만 수정하면 된다. 낮은 응집도와 높은 결합도는 변경해야 하는 부분이 다수의 모듈에 분산돼 있기 때문에 여러 모듈을 동시에 수정해야하는 번거로움이 생긴다.

캡슐화 > 응집도, 결합도

### 설계 트레이드오프

|  | 책임 중심 설계 | 데이터 중심 설계 |
| --- | --- | --- |
| 캡슐화 | O - 객체의 내부 구현을 안정적인 인터페이스 뒤로 캡슐화 | X - 객체의 내부 구현을 인터페이스의 일부로 만든다. |
| 응집도 | O | X - 변경과 상관 없는 코드, 외부 모듈까지 변경에 영향을 받는다. |
| 결합도 | O | X - 내부를 수정하면 외부도 수정해야 한다. |

### 단일 책임 원칙(SRP)

클래스는 단 한 가지의 변경 이유만 가져야 한다.

### 객체는 스스로 자신의 데이터를 책임져야 한다

‘이 객체가 어떤 데이터를 가져야 하는가?’ 라는 질문은 두 개의 개별 질문으로 구분해야 한다.

1. 이 객체가 어떤 데이터를 포함해야 하는가?
2. 이 객체가 데이터에 대해 수행해야 하는 오퍼레이션은 무엇인가?

→ 내부 상태를 저장하는 방식 & 저장된 상태에 대해 호출할 수 있는 오퍼레이션의 집합을 얻을 수 있다.

### 변경의 파급효과

```jsx
public class DiscountCondition {
  private int sequence;
  private DayOfWeek dayOfWeek;

  public boolean isDiscountable(DayOfWeek dayOfWeek) {}
public boolean isDiscountable(int sequence) {}
}
```

이 코드의 문제점은 객체 내부에 DayOfWeek, int 타입의 인스턴스 변수가 포함되어 있다는 사실을 외부에 노출한다는 점이다.

인스턴스 변수의 타입을 변경한다면 두 메서드의 파라미터를 수정하고 해당 메서드를 사용하는 클라이언트도 함께 수정해야할 것이다.

내부 구현 변경이 외부로 퍼져나가는 **파급효과**는 캡슐화가 부족하다는 걸 보여주는 증거이다.

### 캡슐화의 진정한 의미

- NO → 객체 내부의 데이터를 외부로 감추는 것 뿐
- YES → 변경될 수 있는 어떤 것이라도 감추는 것. 구현에 관련된 것이라면 모두!

### 데이터 중심 설계의 문제점

1. 너무 이른 시기에 객체가 가질 데이터에 관해 결정하도록 강요한다. (상태에 초점)
2. 객체를 고립시킨 채 오퍼레이션을 정의하도록 만든다. (객체 내부에 초점을 맞춰 협력을 고려하지 못하고 끼워맞추기 식으로 구현하게 됨)

결과적으로…

1. 객체가 사용될 상황과 책임을 추측하여 설계하므로, 내부 상태를 드러내는 접근자가 많아진다.
    1. ex) getter, setter 메서드명을 통해 객체 내부에 어떤 데이터가 존재하는지 외부에 쉽게 노출된다.
2. 내부를 수정하면 외부도 수정해야하는 경우가 늘어난다.
    1. ex ) 인스턴스 변수의 타입을 변경한다면, getter 메서드 반환 타입도 수정해야 하고, getter 를 호출하는 외부 클래스의 구현도 수정해야 한다.
3. 변경과 상관 없는 코드들까지 변경에 영향을 받을 수 있다.
4. 하나의 요구사항 변경을 반영하기 위해 여러 모듈을 수정하게 된다.

<br>

## 발제

데이터 중심 설계는 절대 사용하면 안 되는 걸까요? 여태까지 항상 이 객체가 어떤 데이터를 가져야하는지 생각하고 정의한 뒤에 메서드를 작성했는데 다른 분들은 어떠신지 궁금하네요.